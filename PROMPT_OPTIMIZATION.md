# Prompt 优化说明

## 问题描述

在初始版本中，生成的 `*_fields.json` 文件中，许多字段的 `text` 字段为空。经过分析发现问题原因：

### 根本原因

视觉模型在识别字段名时会"自动纠正"，导致识别出的 `fieldName` 与 PDF 中实际的字段名不匹配。

**示例**：
- PDF 第二页的实际字段名：`fill_1_P.2`, `fill_2_P.2`, `fill_3_P.2`...（都是 P.2）
- 模型识别的字段名：`fill_1_P.1`, `fill_2_P.2`, `fill_3_P.3`...（递增的页码）

在合并结果时，由于字段名不匹配，导致无法找到对应的标签文字，`text` 字段就为空。

## 解决方案

### 方案1：优化 Prompt（初步尝试）

**改进前的 Prompt**：
```
请仔细分析这张表单图片，识别所有可填写的字段。
对于每个字段，请提供以下信息：
1. fieldName: 字段的名称或标识符（如 fill_1_P.1, fill_2_P.2 等）
2. fieldType: 字段类型（如 text, checkbox, date 等）
3. text: 字段旁边的标签文字或说明文字
```

**改进后的 Prompt**：
```
请仔细分析这张表单图片。图片中用红色边框标注了表单字段，在每个红色边框的左上角有黄色背景的字段名称标签。

你的任务是：
1. 找到每个红色边框标注的字段
2. 读取该字段左上角黄色背景中的字段名称（例如：fill_1_P.2、fill_2_P.2 等）
3. 识别该字段附近的标签文字

重要要求：
- fieldName 必须与图片中红色框左上角黄色背景标注的名称完全一致
```

**效果**：部分改善，但模型仍然会"纠正"字段名

### 方案2：提供字段名列表（最终方案）✅

**核心思路**：不让模型猜测字段名，而是直接提供准确的字段名列表。

**实现步骤**：

1. 从 PDF 中提取准确的字段名列表
2. 在调用视觉 API 时，将字段名列表作为 prompt 的一部分
3. 要求模型使用提供的字段名（而非自己识别）

**优化后的 Prompt**：
```python
field_list = "\n".join([f"- {name}" for name in field_names])
prompt = f"""请仔细分析这张表单图片。图片中用红色边框标注了表单字段，在每个红色边框的左上角有黄色背景显示字段名称。

图片中包含以下字段（已标注在红色框的左上角）：
{field_list}

你的任务是：
对于上述每个字段，识别该字段附近的标签文字（通常在字段左侧或上方，用于说明该字段需要填写什么内容）。

重要要求：
- fieldName 必须使用我提供的字段名（完全一致，包括大小写和点号）
- text 是字段附近的标签文字或说明文字，如果没有明显标签则为空字符串
- 必须包含所有我列出的字段，即使某些字段的 text 为空
```

## 代码修改

### 1. 更新函数签名

**pdf_field_extractor.py:168**
```python
def recognize_field_labels(self, image_path: Path,
                           field_names: Optional[list] = None,  # 新增参数
                           custom_prompt: Optional[str] = None) -> Dict[str, Any]:
```

### 2. 根据是否提供字段名生成不同的 Prompt

**pdf_field_extractor.py:189-214**
```python
if custom_prompt is None:
    if field_names:
        # 提供了字段名列表，生成精确的提示词
        field_list = "\n".join([f"- {name}" for name in field_names])
        custom_prompt = f"""...(包含字段列表的prompt)..."""
    else:
        # 没有提供字段名列表，使用通用提示词
        custom_prompt = """...(让模型自己识别的prompt)..."""
```

### 3. 在调用时传入字段名列表

**pdf_field_extractor.py:395-396**
```python
# 传入字段名列表，让模型使用准确的字段名
field_names_list = list(fields.keys())
labels_result = self.recognize_field_labels(annotated_path, field_names=field_names_list)
```

## 测试结果

### 优化前
```json
[
  {
    "fieldName": "fill_1_P.2",
    "fieldType": "Text",
    "text": ""  // ❌ 空的
  },
  {
    "fieldName": "fill_2_P.2",
    "fieldType": "Text",
    "text": ""  // ❌ 空的
  }
]
```

### 优化后
```json
[
  {
    "fieldName": "fill_1_P.2",
    "fieldType": "text",
    "text": "股份的類別"  // ✅ 正确识别
  },
  {
    "fieldName": "fill_2_P.2",
    "fieldType": "text",
    "text": "附帶的權利的詳情"  // ✅ 正确识别
  }
]
```

### 统计对比

| 页面 | 字段总数 | 优化前识别成功 | 优化后识别成功 |
|------|---------|--------------|--------------|
| 第1页 | 17 | 16 | 17 (100%) ✅ |
| 第2页 | 25 | 0 | 25 (100%) ✅ |

## 关键改进点

1. **准确的字段名匹配**
   - 通过提供字段名列表，确保 `fieldName` 与 PDF 中的实际字段名完全一致

2. **清晰的任务划分**
   - 模型不需要猜测字段名
   - 只需专注于识别标签文字

3. **更好的指令表达**
   - 明确说明图片中的标注（红色边框、黄色背景）
   - 明确区分字段名和标签文字的区别

4. **兼容性保持**
   - 仍然支持不提供字段名列表的情况（使用通用 prompt）
   - 向后兼容 `aliyun_vision_parser.py`

## 经验总结

1. **不要过度依赖模型的"智能"**
   - 模型可能会根据自己的理解"纠正"输入
   - 关键信息应该明确提供，而非让模型猜测

2. **Prompt 工程的最佳实践**
   - 清晰的任务描述
   - 明确的输入和输出格式要求
   - 提供必要的上下文信息

3. **分步验证很重要**
   - 先单独测试视觉识别功能
   - 再集成到完整流程
   - 逐步定位问题根源

## 适用场景

这个优化方案特别适合：

- ✅ 已知字段名的表单（从 PDF 提取）
- ✅ 需要高准确度的字段映射
- ✅ 批量处理相似格式的文档

不太适合：

- ❌ 纯图片表单（无法提取字段名）
- ❌ 手写表单
- ❌ 字段名不规范或不存在的表单

## 后续优化建议

1. **添加字段位置信息到 Prompt**
   - 可以提供字段的大致位置（上/下/左/右）
   - 帮助模型更准确地定位字段和标签的对应关系

2. **支持多语言标签**
   - 优化 prompt 支持纯中文/纯英文/中英混合的标签
   - 根据文档类型调整提示词

3. **增加置信度评分**
   - 对识别结果添加置信度评分
   - 低置信度的结果可以标记供人工审核

4. **智能重试机制**
   - 如果识别结果不完整，自动重试
   - 调整 prompt 或 temperature 参数
